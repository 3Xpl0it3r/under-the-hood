# 垃圾回收器: 屏障技术

[TOC]

本文涉及的文件包括：mwbuf.go, mbarrier.go

我们已经知道了 Go 的垃圾回收器是一个三色并发收集器，即每个对象会被标记为白色、灰色或者黑色。
在 GC 周期的开始前，所有对象都是白色，垃圾回收器的目标是将所有可达对象标记为黑。

内存屏障技术则在 Go 语言中用于保障并发垃圾回收的正确性。
若要讲清楚 Go 中的内存屏障，必须要首先理解并发垃圾回收会产生的问题。

我们已经知道了标记清扫的基本想法：从根集合开始遍历对象图，对出现的对象进行标记，再对未标记的对象进行回收。
这个过程的基本想法是串行的，因为如果没有完成对象图的标记，也就无从得知某个对象是否会在未来被标记，
也就更不能对未标记的对象进行回收。

STW 的引入可想而知能够简化回收器的实现，因为只需要让回收器开始执行时，将并发执行的用户态代码（赋值器）挂起。
这种情况下，对用户态代码而言，回收器是一个原子操作。那么能不能让上面描述的过程并发执行呢？
也就是说当赋值器在执行时，同时执行回收器呢？这就面临一个非常严峻的问题：程序的正确性。

当我们谈论一个垃圾回收程序的正确性时，实际上是在描述用户态代码必须保障回收器不会将存活的对象进行回收，
而回收器也必须保证赋值器能够正确的访问到已经被重新整理和移动的对象。

## 强、弱三色不变性

在没有用户态代码并发修改三色抽象的情况下，回收可以正常结束。但并发回收的根本问题在于，用户态代码
在回收过程中会并发的更新对象图，从而赋值器和回收器可能对对象图的结构产生不同的认知，这时以一个固定的三色波面
作为回收过程前进的边界则不再合理。

我们不妨考虑赋值器的写操作，假设某个灰色对象 A 指向白色对象 B，而此时赋值器并发的将黑色对象 C 指向（ref3）了白色对象 B，
并将灰色对象 A 对白色对象 B 的引用移除（ref2），则在继续扫描的过程中，白色对象 B 永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象）。
进而产生被错误回收的对象 B，如图所示：

![](../../images/mutator.png)

总的来说，产生对象丢失现象必须满足以下两个条件：

1. 赋值器将某一白色对象引用写入黑色对象；
2. 从灰色对象出发，到达白色对象的路径被赋值器破坏。

换言之，如果能够避免其中任何一个条件的出现，则不会出现对象丢失的现象。我们不妨将三色不变性所定义的波面根据这两个条件进行削弱，
当满足原有的三色不变性定义的情况称为强三色不变性，即不存在黑色对象指向白色对象的指针；
当赋值器在黑色对象中写入对白色对象的引用时（条件 1）的情况称为弱三色不变性，即所有黑色对象引用的白色对象都处于灰色保护状态（直接或间接从灰色对象可达）。
当赋值器进一步破坏灰色对象到达白色对象的路径时，即打破弱三色不变性，则也就破坏了回收器的正确性。
可见，在破坏强弱三色不变性时必须引入额外的辅助操作。

## 赋值器的颜色

在考虑三色不变性时，我们从回收器的角度引入了三色不变性。那么如果站在赋值器的角度，是不是也存在某种不变性呢？答案是肯定的。
如果我们考虑并发的用户态代码，回收器不允许同时停止所有赋值器，就是涉及了存在的多个不同状态的赋值器。从而我们可以引入赋值器的颜色：

- 黑色赋值器：已经由回收器扫描过，回收器已完成根的追踪，不会再次对其进行扫描
- 灰色赋值器：尚未被回收器扫描过（回收器的根尚未被追踪到），或尽管已经扫描过但仍需要重新扫描

赋值器的颜色对回收周期的结束产生影响。如果某种并发回收器允许灰色赋值器的存在，则必须在回收结束之前重新扫描赋值器的根。
如果重新扫描过程中发现了新的灰色或白色对象，回收器还需要对新发现的对象进行追踪，但是在新追踪的过程中，赋值器仍然可能
在其根中插入新的非黑色引用，如此往复。
因此允许灰色赋值器存在的算法，最差情况下，回收器只能将所有赋值器线程挂起才能完成其根的完成扫描。

## 新分配对象的颜色

新的分配过程会导致赋值器持有新分配对象的引用。可想而知我们需要为新产生的对象分配适当的颜色。
可想而知，新分配对象的颜色会产生不同的影响：

1. 如果新分配的对象为黑色或者灰色，则赋值器直接将其视为无需回收的对象，写入堆中；
2. 如果新分配的对象为白色，则可以避免无意义的新对象保留到下一个垃圾回收的周期。

如果我们进一步思考，则能够发现，由于黑色赋值器由于已经被回收器扫描过，不会再对其进行任何扫描，一旦其分配新的白色对象
则意味着会导致错误的回收。因此黑色赋值器不能产生白色对象，除非赋值器能够保证分配的白色对象的引用能够被写入到灰色波面中，
但这又是非常困难的。不难看出，为了简化实现复杂度，令新分配的对象为黑色通常是安全的。

## 赋值器屏障技术

在确保强弱三色不变性的并发指针更新操作需要通过赋值器**屏障**技术来保证指针的读写操作一致。

屏障上需要依赖多种操作来应对指针的插入和删除：

- 扩大波面：将白色对象作色成灰色
- 推进波面：扫描对象并将其着色为黑色
- 后退波面：将黑色对象回退到灰色

根据灰色赋值器和黑色赋值器的不同，分别会有不同类别的赋值器屏障。这里我们先介绍两个与 Go 混合内存屏障相关的两个赋值器屏障：
灰色赋值器的 Dijkstra 屏障与黑色赋值器的 Yuasa 屏障。

### 灰色赋值器的 Dijkstra 写屏障

早期的 Go 1.7 使用了纯 Dijkstra 屏障技术。
Dijkstra 屏障对于插入到黑色对象中的白色指针，无论其在未来是否会被赋值器删除，该屏障都会将其标记为可达（着色）：

```go
// Dijkstra 屏障
func writePointer(slot unsafe.Pointer, ptr unsafe.Pointer) {
    shade(ptr)
    *slot = ptr
}

// v1.7
//go:nowritebarrier
func shade(b uintptr) {
	if obj, hbits, span, objIndex := heapBitsForObject(b, 0, 0); obj != 0 {
		gcw := &getg().m.p.ptr().gcw
		greyobject(obj, 0, 0, hbits, span, gcw, objIndex)
		if gcphase == _GCmarktermination || gcBlackenPromptly {
			// Ps aren't allowed to cache work during mark
			// termination.
			gcw.dispose()
		}
	}
}
```

`shade(ptr)` 会将尚未变成灰色或黑色的指针 `ptr` 标记为灰色。通过保守的假设 `*slot` 可能会变为黑色，
并确保 `ptr` 不会在将赋值为 `*slot` 前变为白色，进而确保了强三色不变性。

Dijkstra 屏障与其他类型的屏障相比具有几个优势：

1. 性能优势：它不需要对指针进行任何处理，因为指针的读操作通常比写操作高出一个或更多数量级。
2. 前进保障：与 Steele 写屏障不同，对象可从白色到灰色单调转换为黑色，因此总工作量受到堆大小的显示。

当然，Dijkstra 写屏障也有缺点，尤其是它展示了栈指针的权衡：
当栈上的指针进行写操作时，必须插入写屏障。这就使得该操作相当昂贵，或者要求栈必须是恒灰（permagrey）的。

Go 选择了后者，因此在 STW 期间，必须重新对栈进行扫描。垃圾收集器首先在 GC 循环开始时扫描所有栈从而收集根。
但是如果没有栈的写屏障，我们便无法确保堆栈以后不会包含对白色对象的引用，因此扫描栈只有黑色，直到其 goroutine 再次执行，
因此它保守地恢复为灰色。从而在循环结束时，垃圾回收器必须重新扫描灰色堆栈以使其变黑并完成标记任何剩余堆指针。
由于必须保证栈在此期间不会继续更改，因此重新扫描过程在 STW 时发生。

### 黑色赋值器的 Yuasa 屏障

Yuasa 屏障对于在回收过程中，被赋值器删除最后一个指向这个对象导致该对象不可达的情况，仍将其进行着色。
因此这种情况下精度最低。

```go
// Yuasa 屏障
func Write(slot unsafe.Pointer, ref unsafe.Pointer) {
    if isGrey(*slot) || isWhite(*slot) {
        shade(slot)
    }
    *slot = ref
}
```


## 混合写屏障

混合屏障是 Go 1.8 中引入的特性，它结合了 Yuasa 风格的删除写屏障和 Dijkstra 风格的插入写屏障。
其实现如下：

```go
// 混合写屏障
writePointer(slot, ptr):
    shade(*slot)
    if current stack is grey:
        shade(ptr)
    *slot = ptr
```

换句话说，混合写屏障屏蔽了其引用的被覆盖的对象，并且如果尚未扫描当前 goroutine 的堆栈，则屏蔽正在复制的引用。
混合屏障可以消除栈的重扫过程，因为一旦栈被扫描变为黑色，则它会继续保持黑色。因此，它消除了栈重新扫描相关的机制，
包括栈屏障和重扫列表。此外，混合屏障要求将对象分配为黑色（分配白色是一种常见策略，但与此屏障不兼容）。

混合写屏障等同于 IBM 实时 JAVA 实现中使用的 Metronome 中使用的双写屏障。
这种情况下，垃圾回收器是增量而非并发的，但最终必须处理严格限制的世界时间的相同问题。

## 进一步阅读的参考文献

1. [Eliminate STW stack re-scanning](https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md)

## 许可

[Go under the hood](https://github.com/changkun/go-under-the-hood) | CC-BY-NC-ND 4.0 & MIT &copy; [changkun](https://changkun.de)
