# 垃圾回收器: 并发标记清扫

[TOC]

我们已经知道了标记清扫的基本想法：从根集合开始遍历对象图，对出现的对象进行标记，再对未标记的对象进行回收。
这个过程的基本想法是串行的，因为如果没有完成对象图的标记，也就无从得知某个对象是否会在未来被标记，
也就更不能对未标记的对象进行回收。并且，在对对象进行标记的过程中，也必须进入 STW。

STW 的引入可想而知能够简化回收器的实现，因为只需要让回收器开始执行时，将并发执行的用户态代码（赋值器）挂起。
这种情况下，对用户态代码而言，回收器是一个原子操作。那么能不能让上面描述的过程并发执行呢？
也就是说当赋值器在执行时，同时执行回收器呢？这就面临一个非常严峻的问题：程序的正确性。

当我们谈论一个垃圾回收程序的正确性时，实际上是在描述用户态代码必须保障回收器不会将存活的对象进行回收，
而回收器也必须保证赋值器能够正确的访问到已经被重新整理和移动的对象。

## 强、弱三色不变量

在没有用户态代码并发修改三色抽象的情况下，回收可以正常结束。但并发回收的根本问题在于，用户态代码
在回收过程中会并发的更新对象图，从而赋值器和回收器可能对对象图的结构产生不同的认知，这时以一个固定的三色波面
作为回收过程前进的边界则不再合理。

我们不妨考虑赋值器的写操作，假设某个灰色对象 A 指向白色对象 B，而此时赋值器并发的将黑色对象 C 指向了白色对象 B，
并将灰色对象 A 对白色对象 B 的引用移除，则在继续扫描的过程中，白色对象 B 永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象）。
进而产生被错误回收的对象 B。

总的来说，产生对象丢失现象必须满足以下两个条件：

1. 赋值器将某一白色对象引用写入黑色对象；
2. 从灰色对象出发，到达白色对象的路径被赋值器破坏。

换言之，如果能够避免其中任何一个条件的出现，则不会出现对象丢失的现象。我们不妨将三色不变量所定义的波面根据这两个条件进行削弱，
当满足原有的三色不变量定义的情况称为强三色不变量，即不存在黑色对象指向白色对象的指针；
当赋值器在黑色对象中写入对白色对象的引用时（条件 1）的情况称为弱三色不变量，即所有黑色对象引用的白色对象都处于灰色保护状态（直接或间接从灰色对象可达）。
当赋值器进一步破坏灰色对象到达白色对象的路径时，即打破弱三色不变量，则也就破坏了回收器的正确性。
可见，在破坏强弱三色不变量时必须引入额外的辅助操作。

## 赋值器的颜色

在考虑三色不变性时，我们从回收器的角度引入了三色不变性。那么如果站在赋值器的角度，是不是也存在某种不变性呢？答案是肯定的。
如果我们考虑并发的用户态代码，回收器不允许同时停止所有赋值器，就是涉及了存在的多个不同状态的赋值器。从而我们可以引入赋值器的颜色：

- 黑色赋值器：已经由回收器扫描过，回收器已完成根的追踪，不会再次对其进行扫描
- 灰色赋值器：尚未被回收器扫描过（回收器的根尚未被追踪到），或尽管已经扫描过但仍需要重新扫描

赋值器的颜色对回收周期的结束产生影响。如果某种并发回收器允许灰色赋值器的存在，则必须在回收结束之前重新扫描赋值器的根。
如果重新扫描过程中发现了新的灰色或白色对象，回收器还需要对新发现的对象进行追踪，但是在新追踪的过程中，赋值器仍然可能
在其根中插入新的非黑色引用，如此往复。
因此允许灰色赋值器存在的算法，最差情况下，回收器只能将所有赋值器线程挂起才能完成其根的完成扫描。

<!-- 新分配对象的颜色会产生不同的影响：

1. 如果新分配的对象为黑色或者灰色，则赋值器直接将其视为无需回收的对象，写入堆中；
2.  -->

## 赋值器屏障

屏障上需要依赖多种操作来应对指针的插入和删除：

- 扩大波面：将白色对象作色成灰色
- 推进波面：扫描对象并将其着色为黑色
- 后退波面：将黑色对象回退到灰色

根据灰色赋值器和黑色赋值器的不同，分别会有不同类别的赋值器屏障。
这里我们提到两个与 Go 内存屏障相关的两个赋值器屏障，Dijkstra 屏障与 Yuasa 屏障：

```go
// Dijkstra 屏障
func writePointer(slot unsafe.Pointer, ptr unsafe.Pointer) {
    shade(ptr)
    *slot = ptr
}
```

Dijkstra 屏障对于插入到黑色对象中的白色指针，无论其在未来是否会被赋值器删除，该屏障都会将其标记为可达（着色）。

```go
// Yuasa 屏障
func Write(slot unsafe.Pointer, ref unsafe.Pointer) {
    if isGrey(*slot) || isWhite(*slot) {
        shade(slot)
    }
    *slot = ref
}
```

Yuasa 屏障对于在回收过程中，被赋值器删除最后一个指向这个对象导致该对象不可达的情况，仍将其进行着色。
因此这种情况下精度最低。

TODO: ... 继续思考屏障技术与并发算法之间的先后顺序

## 并发标记

并发标记的思想可以简要描述如下：

```go
func markSome() bool {
    if worklist.empty() {       // 初始化回收过程
        scan(Roots)             // 赋值器不持有任何白色对象的引用
        if worklist.empty() {   // 此时灰色对象已经全部处理完毕
            sweep()             // 标记结束，立即清扫
            return false
        }
    }
    // 回收过程尚未完成，后续过程仍需标记
    ref = worklist.remove()
    scan(ref)
    return true
}

func scan(ref interface{}) {
    for fld := range Pointers(ref) {
        child := *fld
        if child != nil {
            shade(child)
        }
    }
}

func shade(ref interface{}) {
    if !isMarked(ref) {
        setMarked(ref)
        worklist.add(ref)
    }
}
```

在这个过程中，回收器会首先扫描 worklist，而后对根集合进行扫描并重新建立 worklist。
在根集合扫描过程中赋值器现场被挂起时，扫描完成后则不会再存在白色对象。

## 并发清扫

并发清扫的思想可以简要描述如下：

```go
func New() (interface{}, error) {
    collectEnough()
    ref := allocate()
    if ref == nil {
        return nil, errors.New("Out of memory")
    }
    return ref, nil
}

func collectEnough() {
    stopTheWorld()
    defer startTheWorld()
    
    for behind() { // behind() 控制回收工作每次的执行量
        if !markSome() {
            return
        }
    }
}
```


## 并行三色标记

Go 的 GC 与 mutator 线程同时运行，并允许多个 GC 线程并行运行。
它通过写屏障来并发的标记和扫描，是非分代式、非紧凑式 GC。
使用 per-P 分配区隔离的大小来完成分配，从而最小化碎片的产生，也用于消除大部分情况下的锁。

下图展示了 Go 1.5 时的 GC 各阶段：

```
|  GC 尚未启动  | GC 被禁用，指针写仅为内存写：*slot = ptr
                ---
|  执行栈扫描   | 内存 STW；在抢占点，从全局变量和 goroutine 执行栈扫描 
|  标记        | 屏障    ；标记对象以及后继指针，直到指针队列为空；mutator 写屏障追踪指针变化
|  标记终止阶段 | 启用 STW； 重新扫描全局变化的栈、完成标记，收缩栈，...
                ---
|  清扫阶段     | 归还未标记的对象，调整 GC 下个周期的步调
| GC 尚未启动   | 
```

TODO: 混合屏障栈重扫

TODO: go1.12 mark2 stw

## 进一步阅读的参考文献

1. [Getting to Go: The Journey of Go's Garbage Collector](https://blog.golang.org/ismmkeynote)
2. [Eliminate STW stack re-scanning](https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md)

## 许可

[Go under the hood](https://github.com/changkun/go-under-the-hood) | CC-BY-NC-ND 4.0 & MIT &copy; [changkun](https://changkun.de)
